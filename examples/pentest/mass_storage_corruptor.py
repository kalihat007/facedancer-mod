#!/usr/bin/env python3
"""Expose a USB mass storage device with on-the-fly corruptions."""

import argparse
import logging
import os
import random
import sys
from mmap import mmap
from pathlib import Path

ROOT = Path(__file__).resolve().parents[2]
if str(ROOT / "legacy-applets") not in sys.path:
    sys.path.insert(0, str(ROOT / "legacy-applets"))

from facedancer import FacedancerUSBApp
from USBMassStorage import DiskImage, USBMassStorageDevice


class FileBackedCorruptImage(DiskImage):
    """A disk image that corrupts sectors as they are read."""

    def __init__(self, filename: Path, *, block_size: int = 512,
                 flip_probability: float = 0.0, poison_mbr: bool = False,
                 autorun_lba: int = None, autorun_payload: bytes = None,
                 verbose: int = 0):
        self.filename = filename
        self.block_size = block_size
        self.verbose = verbose
        self.flip_probability = flip_probability
        self.poison_mbr = poison_mbr
        self.autorun_lba = autorun_lba
        self.autorun_payload = autorun_payload
        self.random = random.SystemRandom()

        statinfo = os.stat(self.filename)
        self.size = statinfo.st_size

        self._file = open(self.filename, "r+b")
        self._image = mmap(self._file.fileno(), 0)

    def close(self):
        self._image.flush()
        self._image.close()
        self._file.close()

    def get_sector_count(self):
        return int(self.size / self.block_size)

    def _mutate(self, address: int, data: bytearray) -> bytes:
        if self.poison_mbr and address == 0:
            data[:] = os.urandom(len(data))

        if self.flip_probability and self.random.random() < self.flip_probability:
            idx = self.random.randrange(len(data))
            bit = 1 << self.random.randrange(8)
            data[idx] ^= bit

        if self.autorun_payload and self.autorun_lba is not None and address == self.autorun_lba:
            autorun = self.autorun_payload[: len(data)]
            data[:len(autorun)] = autorun

        return bytes(data)

    def get_sector_data(self, address: int):
        start = address * self.block_size
        end = start + self.block_size
        backing = self._image[start:end]
        if self.verbose > 1:
            logging.debug("Serving LBA %d", address)
        return self._mutate(address, bytearray(backing))

    def put_sector_data(self, address: int, data: bytes):
        start = address * self.block_size
        end = start + self.block_size
        if self.verbose:
            logging.info("Write to %d ignored (read-only corruptor)", address)
        self._image[start:end] = data[:self.block_size]


def main_cli():
    parser = argparse.ArgumentParser(description="Mass storage emulator with corrupted sectors")
    parser.add_argument("image", type=Path, help="Path to a disk image to serve")
    parser.add_argument("--flip-prob", type=float, default=0.05,
                        help="Chance of flipping a random bit per sector read (default 0.05)")
    parser.add_argument("--poison-mbr", action="store_true",
                        help="Replace the MBR (LBA0) with random bytes on every read")
    parser.add_argument("--autorun", type=Path,
                        help="Path to an autorun payload to inject at --autorun-lba")
    parser.add_argument("--autorun-lba", type=int,
                        help="Logical block address where the autorun payload should appear")
    parser.add_argument("--log", default="INFO", help="Logging level (default INFO)")

    args = parser.parse_args()
    logging.basicConfig(level=getattr(logging, args.log.upper(), logging.INFO),
                        format="[%(levelname)s] %(message)s")

    autorun_payload = None
    if args.autorun:
        autorun_payload = args.autorun.read_bytes()
        logging.info("Loaded autorun payload (%d bytes)", len(autorun_payload))

    image = FileBackedCorruptImage(args.image,
                                   flip_probability=args.flip_prob,
                                   poison_mbr=args.poison_mbr,
                                   autorun_lba=args.autorun_lba,
                                   autorun_payload=autorun_payload)

    app = FacedancerUSBApp(verbose=1)
    device = USBMassStorageDevice(app, image, verbose=2)

    device.connect()

    try:
        device.run()
    except KeyboardInterrupt:
        pass
    finally:
        device.disconnect()
        image.close()


if __name__ == "__main__":
    main_cli()
