#!/usr/bin/env python3
"""Load a USB Rubber Ducky style payload file and replay it as a HID keyboard."""

import argparse
import asyncio
import logging
from pathlib import Path

from facedancer import main
from facedancer.devices.keyboard import USBKeyboardDevice
from facedancer.classes.hid.keyboard import KeyboardModifiers, KeyboardKeys


MODIFIER_MAP = {
    "CTRL": KeyboardModifiers.MOD_LEFT_CTRL,
    "CONTROL": KeyboardModifiers.MOD_LEFT_CTRL,
    "SHIFT": KeyboardModifiers.MOD_LEFT_SHIFT,
    "ALT": KeyboardModifiers.MOD_LEFT_ALT,
    "GUI": KeyboardModifiers.MOD_LEFT_META,
    "WINDOWS": KeyboardModifiers.MOD_LEFT_META,
}


SPECIAL_KEYS = {
    "ENTER": KeyboardKeys.ENTER,
    "RETURN": KeyboardKeys.ENTER,
    "SPACE": KeyboardKeys.SPACE,
    "TAB": KeyboardKeys.TAB,
    "BACKSPACE": KeyboardKeys.BACKSPACE,
    "ESC": KeyboardKeys.ESC,
    "ESCAPE": KeyboardKeys.ESC,
    "DELETE": KeyboardKeys.DELETE,
    "DEL": KeyboardKeys.DELETE,
    "UP": KeyboardKeys.UP,
    "DOWN": KeyboardKeys.DOWN,
    "LEFT": KeyboardKeys.LEFT,
    "RIGHT": KeyboardKeys.RIGHT,
    "HOME": KeyboardKeys.HOME,
    "END": KeyboardKeys.END,
    "PAGEUP": KeyboardKeys.PAGEUP,
    "PAGEDOWN": KeyboardKeys.PAGEDOWN,
    "INSERT": KeyboardKeys.INSERT,
    "CAPSLOCK": KeyboardKeys.CAPSLOCK,
    "NUMLOCK": KeyboardKeys.NUMLOCK,
    "PRINTSCREEN": KeyboardKeys.SYSRQ,
    "SCROLLLOCK": KeyboardKeys.SCROLLLOCK,
}


def lookup_key(name: str) -> KeyboardKeys:
    """Resolve a DuckyScript key name to a KeyboardKeys entry."""

    normalized = name.replace("-", "").replace(" ", "").upper()

    if normalized in SPECIAL_KEYS:
        return SPECIAL_KEYS[normalized]

    # Allow function keys like F1..F24
    if normalized.startswith("F") and normalized[1:].isdigit():
        fn = f"F{int(normalized[1:])}"
        if fn in KeyboardKeys.__members__:
            return KeyboardKeys[fn]

    if normalized in KeyboardKeys.__members__:
        return KeyboardKeys[normalized]

    raise ValueError(f"Unsupported key token: {name}")


def parse_ducky_lines(path: Path):
    """Yield tokenized commands from a payload file."""

    with path.open("r", encoding="utf-8") as payload:
        for raw_line in payload:
            stripped = raw_line.strip()

            if not stripped or stripped.startswith("REM"):
                continue

            yield stripped.split()


async def run_payload(device: USBKeyboardDevice, commands, *, default_delay_ms: int, initial_delay: float):
    """Execute the parsed command stream against the emulated keyboard."""

    await asyncio.sleep(initial_delay)

    for tokens in commands:
        command = tokens[0].upper()
        args = tokens[1:]

        if command == "DEFAULT_DELAY" and args:
            default_delay_ms = int(args[0])
            logging.info("Default delay set to %sms", default_delay_ms)
            continue

        if command == "DELAY" and args:
            await asyncio.sleep(int(args[0]) / 1000.0)
            continue

        if command == "STRING":
            text = " ".join(tokens[1:])
            await device.type_string(text)
            await asyncio.sleep(default_delay_ms / 1000.0)
            continue

        if command == "STRINGLN":
            text = " ".join(tokens[1:])
            await device.type_string(text + "\n")
            await asyncio.sleep(default_delay_ms / 1000.0)
            continue

        modifiers = KeyboardModifiers(0)
        resolved_keys = []

        for token in tokens:
            upper = token.upper()
            if upper in MODIFIER_MAP:
                modifiers |= MODIFIER_MAP[upper]
            else:
                resolved_keys.append(lookup_key(token))

        if not resolved_keys:
            logging.warning("Ignored line with no key tokens: %s", tokens)
            continue

        # Press keys sequentially while holding the collected modifiers.
        for key in resolved_keys:
            await device.type_scancode(key, modifiers=modifiers)

        await asyncio.sleep(default_delay_ms / 1000.0)


def main_cli():
    parser = argparse.ArgumentParser(description="Replay DuckyScript payloads via FaceDancer keyboard emulation")
    parser.add_argument("payload", type=Path, help="Path to payload.txt containing DuckyScript commands")
    parser.add_argument("--default-delay", type=int, default=100,
                        help="Default delay between commands in milliseconds (default 100)")
    parser.add_argument("--initial-delay", type=float, default=5.0,
                        help="Seconds to wait before starting the payload (default 5s)")
    parser.add_argument("--log", default="INFO", help="Logging level (default INFO)")

    args, remaining = parser.parse_known_args()
    # Ensure FaceDancer's default_main sees only its recognized options.
    import sys
    sys.argv = [sys.argv[0], *remaining]
    logging.basicConfig(level=getattr(logging, args.log.upper(), logging.INFO), format="[%(levelname)s] %(message)s")

    commands = list(parse_ducky_lines(args.payload))

    device = USBKeyboardDevice()
    coroutine = run_payload(device, commands,
                            default_delay_ms=args.default_delay,
                            initial_delay=args.initial_delay)

    main(device, coroutine)


if __name__ == "__main__":
    main_cli()
